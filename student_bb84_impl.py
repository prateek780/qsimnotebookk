# Auto-exported Student BB84 implementation
# This file is automatically generated from the notebook
# Do not edit manually - changes will be overwritten
import random

class StudentQuantumHost:
    """
    Student's BB84 implementation - extracted from notebook!
    This is the exact code from the student's vibe implementation.
    """
    
    def __init__(self, name):
        """Initialize a StudentQuantumHost instance."""
        # Store the host name for use in log messages
        self.name = name
        
        # Initialize empty lists to track quantum communication data
        self.random_bits = []              # Random classical bits generated
        self.measurement_bases = []        # Measurement bases chosen for encoding
        self.quantum_states = []           # Quantum states encoded
        self.received_bases = []           # Measurement bases used when receiving qubits
        self.measurement_outcomes = []     # Measurement outcomes obtained
        
        # Print dynamic welcome message
        print(f"üîπ StudentQuantumHost '{self.name}' initialized successfully!")

    def bb84_send_qubits(self, num_qubits):
        """Alice's BB84 implementation: Prepare and send qubits"""
        # Display initial message with sender identity and total qubits
        print(f"üîπ {self.name} is preparing {num_qubits} qubits for BB84 transmission...")
        
        # Reinitialize internal storage structures for preparation data
        self.random_bits = []
        self.measurement_bases = []
        self.quantum_states = []
        
        # Process each qubit
        for i in range(num_qubits):
            # Create a random classical value (0 or 1)
            classical_bit = random.randint(0, 1)
            
            # Choose a random preparation setting (basis: 0 for rectilinear, 1 for diagonal)
            preparation_basis = random.randint(0, 1)
            
            # Transform classical value into quantum state using chosen setting
            if preparation_basis == 0:  # Rectilinear basis (Z-basis)
                if classical_bit == 0:
                    quantum_state = "|0‚ü©"  # |0‚ü© state
                else:
                    quantum_state = "|1‚ü©"  # |1‚ü© state
            else:  # Diagonal basis (X-basis)
                if classical_bit == 0:
                    quantum_state = "|+‚ü©"  # |+‚ü© state = (|0‚ü© + |1‚ü©)/‚àö2
                else:
                    quantum_state = "|-‚ü©"  # |-‚ü© state = (|0‚ü© - |1‚ü©)/‚àö2
            
            # Store results in internal collections
            self.random_bits.append(classical_bit)
            self.measurement_bases.append(preparation_basis)
            self.quantum_states.append(quantum_state)
        
        # Display summary after all qubits are processed
        print(f" Summary for {self.name}:")
        print(f"   ‚Ä¢ Prepared {len(self.quantum_states)} qubits")
        print(f"   ‚Ä¢ Random bits preview: {self.random_bits[:min(10, len(self.random_bits))]}{'...' if len(self.random_bits) > 10 else ''}")
        print(f"   ‚Ä¢ Preparation bases preview: {self.measurement_bases[:min(10, len(self.measurement_bases))]}{'...' if len(self.measurement_bases) > 10 else ''}")
        print(f"   ‚Ä¢ Quantum states preview: {self.quantum_states[:min(10, len(self.quantum_states))]}{'...' if len(self.quantum_states) > 10 else ''}")
        
        # Return the collection of prepared quantum states
        return self.quantum_states

    def process_received_qbit(self, qbit, from_channel):
        """Bob's BB84 implementation: Receive and measure qubits"""
        # Select a random measurement setting (0 for rectilinear, 1 for diagonal)
        measurement_basis = random.randint(0, 1)
        
        # Record the chosen setting in the appropriate internal collection
        self.received_bases.append(measurement_basis)
        
        # Perform measurement of the received quantum state using the chosen setting
        if measurement_basis == 0:  # Rectilinear basis (Z-basis) measurement
            if qbit == "|0‚ü©":
                outcome = 0  # Measuring |0‚ü© in Z-basis always gives 0
            elif qbit == "|1‚ü©":
                outcome = 1  # Measuring |1‚ü© in Z-basis always gives 1
            elif qbit == "|+‚ü©":
                outcome = random.randint(0, 1)  # |+‚ü© in Z-basis: 50% chance of 0 or 1
            elif qbit == "|-‚ü©":
                outcome = random.randint(0, 1)  # |-‚ü© in Z-basis: 50% chance of 0 or 1
            else:
                # Handle unexpected quantum state
                outcome = random.randint(0, 1)
                
        else:  # Diagonal basis (X-basis) measurement
            if qbit == "|+‚ü©":
                outcome = 0  # Measuring |+‚ü© in X-basis always gives 0
            elif qbit == "|-‚ü©":
                outcome = 1  # Measuring |-‚ü© in X-basis always gives 1
            elif qbit == "|0‚ü©":
                outcome = random.randint(0, 1)  # |0‚ü© in X-basis: 50% chance of 0 or 1
            elif qbit == "|1‚ü©":
                outcome = random.randint(0, 1)  # |1‚ü© in X-basis: 50% chance of 0 or 1
            else:
                # Handle unexpected quantum state
                outcome = random.randint(0, 1)
        
        # Store the resulting outcome in the internal collection of measurement results
        self.measurement_outcomes.append(outcome)
        
        # Return confirmation value indicating successful processing
        return True

    def bb84_reconcile_bases(self, alice_bases, bob_bases):
        """BB84 basis reconciliation: Find matching measurement bases"""
        # Display message indicating basis comparison
        print(f"üîπ {self.name} is comparing basis choices for reconciliation...")
        
        # Create empty collections for matching indices and corresponding bit values
        matching_indices = []
        corresponding_bits = []
        
        # Iterate through both sets of basis choices simultaneously with their positions
        for position, (alice_basis, bob_basis) in enumerate(zip(alice_bases, bob_bases)):
            # Check if the two bases are the same
            if alice_basis == bob_basis:
                # Record the index where bases align
                matching_indices.append(position)
                
                # If a corresponding measurement result exists, record the measured value
                if position < len(self.measurement_outcomes):
                    corresponding_bits.append(self.measurement_outcomes[position])
                elif position < len(self.random_bits):
                    # For Alice, use the original random bits
                    corresponding_bits.append(self.random_bits[position])
        
        # Display summary after completing the comparison
        total_comparisons = min(len(alice_bases), len(bob_bases))
        matches_found = len(matching_indices)
        match_proportion = matches_found / total_comparisons if total_comparisons > 0 else 0
        
        print(f" Basis Reconciliation Summary for {self.name}:")
        print(f"   ‚Ä¢ Matches found: {matches_found}")
        print(f"   ‚Ä¢ Total comparisons: {total_comparisons}")
        print(f"   ‚Ä¢ Match proportion: {match_proportion:.3f} ({match_proportion*100:.1f}%)")
        print(f"   ‚Ä¢ Matching indices: {matching_indices[:min(10, len(matching_indices))]}{'...' if len(matching_indices) > 10 else ''}")
        
        # Return both the list of matching indices and corresponding bit values
        return matching_indices, corresponding_bits

    def bb84_estimate_error_rate(self, sample_positions, reference_bits):
        """BB84 error rate estimation: Compare sample bits to detect eavesdropping"""
        # Display message indicating error rate calculation
        print(f"üîπ {self.name} is calculating the error rate from sample comparison...")
        
        # Set up counters to track comparisons and discrepancies
        comparison_count = 0
        error_count = 0
        
        # Iterate through the provided sample positions and reference bits
        for position, reference_bit in zip(sample_positions, reference_bits):
            # Check if the position is valid relative to this host's recorded outcomes
            if position < len(self.measurement_outcomes):
                # Increase the comparison count for valid positions
                comparison_count += 1
                
                # Get the recorded outcome for this position
                recorded_outcome = self.measurement_outcomes[position]
                
                # If the recorded outcome does not match the provided reference bit, increase error count
                if recorded_outcome != reference_bit:
                    error_count += 1
            elif position < len(self.random_bits):
                # For Alice's case, compare against original random bits
                comparison_count += 1
                recorded_outcome = self.random_bits[position]
                
                if recorded_outcome != reference_bit:
                    error_count += 1
        
        # Calculate error rate as ratio of errors to comparisons, defaulting to zero if no comparisons
        error_rate = error_count / comparison_count if comparison_count > 0 else 0.0
        
        # Display summary with calculated error rate and raw counts
        print(f"üìä Error Rate Estimation Summary for {self.name}:")
        print(f"   ‚Ä¢ Total comparisons: {comparison_count}")
        print(f"   ‚Ä¢ Errors detected: {error_count}")
        print(f"   ‚Ä¢ Calculated error rate: {error_rate:.4f} ({error_rate*100:.2f}%)")
        
        # Interpret the error rate
        if error_rate == 0.0:
            print(f"   ‚Ä¢ Status: No errors detected - channel appears secure")
        elif error_rate <= 0.11:  # Typical threshold for BB84
            print(f"   ‚Ä¢ Status: Low error rate - likely due to noise")
        else:
            print(f"   ‚Ä¢ Status: High error rate - possible eavesdropping detected!")
        
        # Return the computed error rate
        return error_rate
