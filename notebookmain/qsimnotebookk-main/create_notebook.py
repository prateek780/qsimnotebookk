#!/usr/bin/env python3
"""
Create Jupyter Notebook for Quantum Networking with BB84 Protocol
===============================================================

This script helps you create a comprehensive Jupyter notebook
for learning quantum networking and implementing BB84 protocol.
"""

import json
import os

def create_quantum_notebook():
    """Create a comprehensive quantum networking notebook."""
    
    notebook = {
        "cells": [
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "# üöÄ Quantum Networking with BB84 Protocol\n",
                    "\n",
                    "**Interactive Learning Notebook for Students**\n",
                    "\n",
                    "This notebook will teach you:\n",
                    "- üåê **Introduction to Quantum Networking**\n",
                    "- üîê **BB84 Quantum Key Distribution Protocol**\n",
                    "- üíª **Code Scaffolding** for hands-on implementation\n",
                    "- ü§ñ **GitHub Copilot Integration** for AI-assisted coding\n",
                    "- üéÆ **Interactive Simulations** and visualizations\n",
                    "\n",
                    "---\n",
                    "\n",
                    "**üéØ Goal**: By the end of this notebook, you'll implement BB84 QKD between 2 quantum hosts!\n",
                    "\n",
                    "**‚è±Ô∏è Timeline**: 1-2 days of hands-on learning\n",
                    "\n",
                    "**üîß Prerequisites**: Basic Python knowledge, curiosity about quantum mechanics"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## üìã Section 1: Setup and Dependencies\n",
                    "\n",
                    "First, let's install and import all necessary libraries for quantum simulation."
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Install required packages (run this cell first if needed)\n",
                    "# !pip install qutip numpy matplotlib seaborn ipywidgets plotly"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Import all necessary libraries\n",
                    "import numpy as np\n",
                    "import matplotlib.pyplot as plt\n",
                    "import seaborn as sns\n",
                    "import qutip as qt\n",
                    "from qutip import *\n",
                    "import warnings\n",
                    "from typing import List, Tuple, Dict, Any\n",
                    "\n",
                    "# Suppress warnings for cleaner output\n",
                    "warnings.filterwarnings('ignore')\n",
                    "\n",
                    "# Set plotting style\n",
                    "plt.style.use('default')\n",
                    "sns.set_palette(\"husl\")\n",
                    "\n",
                    "print(\"üöÄ Quantum Networking with BB84 Protocol\")\n",
                    "print(\"=\" * 50)\n",
                    "print(\"‚úÖ All libraries imported successfully!\")\n",
                    "print(f\"Qutip version: {qt.__version__}\")\n",
                    "print(f\"NumPy version: {np.__version__}\")\n",
                    "print(f\"Matplotlib version: {plt.matplotlib.__version__}\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## üåê Section 2: Introduction to Quantum Networking\n",
                    "\n",
                    "### What is Quantum Networking?\n",
                    "\n",
                    "Quantum networking is the next frontier in secure communications. Unlike classical networks that rely on mathematical complexity for security, quantum networks use the fundamental principles of quantum mechanics to provide **unconditional security**.\n",
                    "\n",
                    "### Key Concepts:\n",
                    "\n",
                    "#### üî¨ **Quantum Superposition**\n",
                    "- A qubit can exist in multiple states simultaneously\n",
                    "- Example: |œà‚ü© = Œ±|0‚ü© + Œ≤|1‚ü© where |Œ±|¬≤ + |Œ≤|¬≤ = 1\n",
                    "- This enables quantum parallelism and new communication protocols\n",
                    "\n",
                    "#### üì° **Quantum Entanglement**\n",
                    "- Two or more qubits can be correlated across distance\n",
                    "- Einstein called this \"spooky action at a distance\"\n",
                    "- Enables quantum teleportation and secure key distribution\n",
                    "\n",
                    "#### üõ°Ô∏è **Quantum Security**\n",
                    "- Any eavesdropping attempt disturbs the quantum state\n",
                    "- This disturbance can be detected, making eavesdropping impossible\n",
                    "- Provides information-theoretic security"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Interactive quantum state visualization\n",
                    "def visualize_qubit_state(alpha: float, beta: float) -> None:\n",
                    "    \"\"\"\n",
                    "    Visualize a qubit state |œà‚ü© = Œ±|0‚ü© + Œ≤|1‚ü©\n",
                    "    \n",
                    "    Args:\n",
                    "        alpha: Amplitude of |0‚ü© state\n",
                    "        beta: Amplitude of |1‚ü© state\n",
                    "    \"\"\"\n",
                    "    \n",
                    "    # Normalize the state\n",
                    "    norm = np.sqrt(alpha**2 + beta**2)\n",
                    "    alpha_norm = alpha / norm\n",
                    "    beta_norm = beta / norm\n",
                    "    \n",
                    "    # Create Bloch sphere visualization\n",
                    "    fig = plt.figure(figsize=(15, 5))\n",
                    "    \n",
                    "    # Bloch sphere\n",
                    "    ax1 = fig.add_subplot(131, projection='3d')\n",
                    "    b = qt.Bloch(axes=ax1)\n",
                    "    state = alpha_norm * qt.basis(2, 0) + beta_norm * qt.basis(2, 1)\n",
                    "    b.add_states(state)\n",
                    "    b.render()\n",
                    "    ax1.set_title(f'Bloch Sphere: |œà‚ü© = {alpha_norm:.2f}|0‚ü© + {beta_norm:.2f}|1‚ü©')\n",
                    "    \n",
                    "    # State vector\n",
                    "    ax2 = fig.add_subplot(132)\n",
                    "    states = ['|0‚ü©', '|1‚ü©']\n",
                    "    amplitudes = [abs(alpha_norm), abs(beta_norm)]\n",
                    "    phases = [np.angle(alpha_norm), np.angle(beta_norm)]\n",
                    "    \n",
                    "    bars = ax2.bar(states, amplitudes, color=['skyblue', 'lightcoral'])\n",
                    "    ax2.set_ylabel('Amplitude')\n",
                    "    ax2.set_title('State Amplitudes')\n",
                    "    \n",
                    "    # Add phase information\n",
                    "    for i, (bar, phase) in enumerate(zip(bars, phases)):\n",
                    "        height = bar.get_height()\n",
                    "        ax2.text(bar.get_x() + bar.get_width()/2., height + 0.01,\n",
                    "                f'œÜ={phase:.2f}', ha='center', va='bottom')\n",
                    "    \n",
                    "    # Phase plot\n",
                    "    ax3 = fig.add_subplot(133, projection='polar')\n",
                    "    angles = [0, np.angle(alpha_norm), np.angle(beta_norm)]\n",
                    "    radii = [0, abs(alpha_norm), abs(beta_norm)]\n",
                    "    ax3.scatter(angles[1:], radii[1:], c=['skyblue', 'lightcoral'], s=100)\n",
                    "    ax3.set_title('Phase Representation')\n",
                    "    \n",
                    "    plt.tight_layout()\n",
                    "    plt.show()\n",
                    "    \n",
                    "    # Print state information\n",
                    "    print(f\"\\nüìä State Information:\")\n",
                    "    print(f\"Normalized state: |œà‚ü© = {alpha_norm:.3f}|0‚ü© + {beta_norm:.3f}|1‚ü©\")\n",
                    "    print(f\"Probability of |0‚ü©: {abs(alpha_norm)**2:.3f}\")\n",
                    "    print(f\"Probability of |1‚ü©: {abs(beta_norm)**2:.3f}\")\n",
                    "    print(f\"Phase of |0‚ü©: {np.angle(alpha_norm):.3f} radians\")\n",
                    "    print(f\"Phase of |1‚ü©: {np.angle(beta_norm):.3f} radians\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## üîê Section 3: BB84 Protocol Deep Dive\n",
                    "\n",
                    "### What is BB84?\n",
                    "\n",
                    "**BB84** (Bennett-Brassard 1984) is the first and most famous quantum key distribution protocol. It allows two parties (traditionally called Alice and Bob) to establish a shared secret key while detecting any eavesdropping attempts.\n",
                    "\n",
                    "### üéØ **The Problem BB84 Solves:**\n",
                    "\n",
                    "In classical cryptography, security relies on mathematical complexity. But what if someone builds a powerful enough computer to break it? BB84 provides **information-theoretic security** - it's secure regardless of computing power.\n",
                    "\n",
                    "### üîÑ **How BB84 Works (Step by Step):**\n",
                    "\n",
                    "#### **Step 1: Alice's Preparation**\n",
                    "1. Alice generates random bits (0 or 1)\n",
                    "2. For each bit, she randomly chooses a basis:\n",
                    "   - **Computational basis**: |0‚ü©, |1‚ü©\n",
                    "   - **Hadamard basis**: |+‚ü© = (|0‚ü© + |1‚ü©)/‚àö2, |‚àí‚ü© = (|0‚ü© - |1‚ü©)/‚àö2\n",
                    "3. She encodes each bit in the chosen basis and sends the qubits to Bob\n",
                    "\n",
                    "#### **Step 2: Bob's Measurement**\n",
                    "1. Bob receives the qubits\n",
                    "2. For each qubit, he randomly chooses a measurement basis\n",
                    "3. He measures each qubit and records the result\n",
                    "\n",
                    "#### **Step 3: Basis Comparison**\n",
                    "1. Alice and Bob publicly compare their basis choices\n",
                    "2. They keep only the bits where bases matched\n",
                    "3. These matching bits form their shared key\n",
                    "\n",
                    "#### **Step 4: Eavesdropper Detection**\n",
                    "1. Alice and Bob compare a subset of their shared bits\n",
                    "2. If there are too many errors, they know Eve was listening\n",
                    "3. If error rate is low, they can be confident the key is secure"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# BB84 Protocol Implementation - Code Scaffolding\n",
                    "# This is where YOU will implement the protocol!\n",
                    "\n",
                    "class BB84Protocol:\n",
                    "    \"\"\"\n",
                    "    Implementation of the BB84 quantum key distribution protocol.\n",
                    "    \n",
                    "    This class provides the structure for implementing BB84 between two quantum hosts.\n",
                    "    You will fill in the implementation details!\n",
                    "    \"\"\"\n",
                    "    \n",
                    "    def __init__(self, key_length: int = 100):\n",
                    "        \"\"\"\n",
                    "        Initialize BB84 protocol.\n",
                    "        \n",
                    "        Args:\n",
                    "            key_length: Length of the key to generate\n",
                    "        \"\"\"\n",
                    "        self.key_length = key_length\n",
                    "        self.alice_bits = None\n",
                    "        self.alice_bases = None\n",
                    "        self.bob_bases = None\n",
                    "        self.bob_measurements = None\n",
                    "        self.shared_key = None\n",
                    "        self.eavesdropper_present = False\n",
                    "        \n",
                    "    def alice_prepare_qubits(self) -> Tuple[np.ndarray, np.ndarray]:\n",
                    "        \"\"\"\n",
                    "        TODO: Implement Alice's qubit preparation for BB84 protocol\n",
                    "        \n",
                    "        Steps to implement:\n",
                    "        1. Generate random bits (0 or 1)\n",
                    "        2. Generate random bases (0 for computational, 1 for Hadamard)\n",
                    "        3. Store the bits and bases for later use\n",
                    "        \n",
                    "        Returns:\n",
                    "            Tuple of (bits, bases)\n",
                    "        \"\"\"\n",
                    "        # TODO: Your implementation here!\n",
                    "        # Hint: Use np.random.randint(2, size=self.key_length) for random bits\n",
                    "        \n",
                    "        pass\n",
                    "    \n",
                    "    def encode_qubit(self, bit: int, base: int) -> qt.Qobj:\n",
                    "        \"\"\"\n",
                    "        TODO: Encode a bit into a qubit using the specified base\n",
                    "        \n",
                    "        Args:\n",
                    "            bit: Bit value (0 or 1)\n",
                    "            base: Basis choice (0 for computational, 1 for Hadamard)\n",
                    "            \n",
                    "        Returns:\n",
                    "            Quantum state representing the encoded bit\n",
                    "        \"\"\"\n",
                    "        # TODO: Your implementation here!\n",
                    "        # \n",
                    "        # If base == 0 (computational basis):\n",
                    "        #   - bit 0 ‚Üí |0‚ü©\n",
                    "        #   - bit 1 ‚Üí |1‚ü©\n",
                    "        # \n",
                    "        # If base == 1 (Hadamard basis):\n",
                    "        #   - bit 0 ‚Üí |0‚ü© = (|0‚ü© + |1‚ü©)/‚àö2\n",
                    "        #   - bit 1 ‚Üí |1‚ü© = (|0‚ü© - |1‚ü©)/‚àö2\n",
                    "        # \n",
                    "        # Hint: Use qt.basis(2, 0) for |0‚ü© and qt.basis(2, 1) for |1‚ü©\n",
                    "        \n",
                    "        pass\n",
                    "    \n",
                    "    def bob_measure_qubits(self, qubits: List[qt.Qobj], \n",
                    "                          eavesdropper_interference: bool = False) -> Tuple[np.ndarray, np.ndarray]:\n",
                    "        \"\"\"\n",
                    "        TODO: Bob measures qubits in random bases\n",
                    "        \n",
                    "        Args:\n",
                    "            qubits: List of quantum states to measure\n",
                    "            eavesdropper_interference: Whether to simulate eavesdropper interference\n",
                    "            \n",
                    "        Returns:\n",
                    "            Tuple of (bob_bases, bob_measurements)\n",
                    "        \"\"\"\n",
                    "        # TODO: Your implementation here!\n",
                    "        # \n",
                    "        # Steps:\n",
                    "        # 1. Generate random bases for Bob (same as Alice)\n",
                    "        # 2. For each qubit:\n",
                    "        #    - If Bob's basis matches Alice's: measure correctly\n",
                    "        #    - If bases don't match: result is random\n",
                    "        # 3. Simulate eavesdropper if requested\n",
                    "        # \n",
                    "        # Hint: Use qt.mesolve() for measurements\n",
                    "        \n",
                    "        pass\n",
                    "    \n",
                    "    def establish_shared_key(self) -> Tuple[np.ndarray, float, bool]:\n",
                    "        \"\"\"\n",
                    "        TODO: Establish shared key by comparing bases and keeping matching measurements\n",
                    "        \n",
                    "        Returns:\n",
                    "            Tuple of (shared_key, error_rate, eavesdropper_detected)\n",
                    "        \"\"\"\n",
                    "        # TODO: Your implementation here!\n",
                    "        # \n",
                    "        # Steps:\n",
                    "        # 1. Find positions where Alice's and Bob's bases match\n",
                    "        # 2. Extract the corresponding bits from both parties\n",
                    "        # 3. Compare the bits to detect errors\n",
                    "        # 4. Calculate error rate\n",
                    "        # 5. Determine if eavesdropper is present (error_rate > threshold)\n",
                    "        # \n",
                    "        # Hint: Use np.where() to find matching bases\n",
                    "        \n",
                    "        pass\n",
                    "    \n",
                    "    def run_protocol(self, eavesdropper_interference: bool = False) -> Dict[str, Any]:\n",
                    "        \"\"\"\n",
                    "        TODO: Run the complete BB84 protocol\n",
                    "        \n",
                    "        Args:\n",
                    "            eavesdropper_interference: Whether to simulate eavesdropper interference\n",
                    "            \n",
                    "        Returns:\n",
                    "            Dictionary containing protocol results\n",
                    "        \"\"\"\n",
                    "        # TODO: Your implementation here!\n",
                    "        # \n",
                    "        # Steps:\n",
                    "        # 1. Call alice_prepare_qubits()\n",
                    "        # 2. Encode qubits using encode_qubit()\n",
                    "        # 3. Call bob_measure_qubits()\n",
                    "        # 4. Call establish_shared_key()\n",
                    "        # 5. Return results\n",
                    "        # \n",
                    "        # This is the main orchestrator function!\n",
                    "        \n",
                    "        pass\n",
                    "\n",
                    "print(\"üîß BB84 Protocol Code Scaffolding Created!\")\n",
                    "print(\"=\" * 50)\n",
                    "print(\"üí° Now it's your turn to implement each method!\")\n",
                    "print(\"üöÄ Start with alice_prepare_qubits() and work your way up.\")\n",
                    "print(\"ü§ñ Use GitHub Copilot to help with the implementation.\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## üéÆ Section 4: Interactive Implementation\n",
                    "\n",
                    "Now let's test your implementation! Run the cells below to see how your BB84 protocol works.\n",
                    "\n",
                    "### üß™ **Testing Your Implementation:**\n",
                    "\n",
                    "1. **First**: Make sure you've implemented all the TODO methods above\n",
                    "2. **Then**: Run the test cells below\n",
                    "3. **Finally**: Experiment with different parameters\n",
                    "\n",
                    "### üí° **GitHub Copilot Tips:**\n",
                    "\n",
                    "- **Clear comments**: Describe what you want to achieve\n",
                    "- **Function signatures**: Define clear input/output\n",
                    "- **Step-by-step plans**: Break complex operations into steps\n",
                    "- **Error handling**: Ask for robust error handling"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Test your BB84 implementation\n",
                    "print(\"üß™ Testing Your BB84 Implementation\")\n",
                    "print(\"=\" * 50)\n",
                    "\n",
                    "# Create BB84 instance with smaller key length for testing\n",
                    "bb84 = BB84Protocol(key_length=20)\n",
                    "\n",
                    "try:\n",
                    "    # Test the protocol (no eavesdropper)\n",
                    "    print(\"\\nüîê Testing BB84 Protocol (No Eavesdropper)\")\n",
                    "    result_secure = bb84.run_protocol(eavesdropper_interference=False)\n",
                    "    \n",
                    "    print(f\"\\nüìä Results Summary:\")\n",
                    "    print(f\"Shared key: {result_secure['shared_key']}\")\n",
                    "    print(f\"Key length: {len(result_secure['shared_key'])}\")\n",
                    "    print(f\"Error rate: {result_secure['error_rate']:.3f}\")\n",
                    "print(f\"Eavesdropper detected: {result_secure['eavesdropper_detected']}\")\n",
                    "    \n",
                    "except Exception as e:\n",
                    "    print(f\"‚ùå Error: {e}\")\n",
                    "    print(\"üí° Make sure you've implemented all the TODO methods above!\")"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## ü§ñ Section 5: GitHub Copilot Integration\n",
                    "\n",
                    "### How GitHub Copilot Helps with Quantum Code\n",
                    "\n",
                    "GitHub Copilot can significantly accelerate your quantum programming by:\n",
                    "- **Auto-completing quantum circuits** - Suggests quantum operations\n",
                    "- **Generating measurement code** - Automatic quantum measurement implementation\n",
                    "- **Providing algorithm patterns** - Common quantum computing patterns\n",
                    "- **Assisting with error handling** - Robust quantum operation error handling\n",
                    "\n",
                    "### üéØ **Best Practices for Copilot + Quantum Code**\n",
                    "\n",
                    "1. **Clear Comments**: Write descriptive comments about what you want\n",
                    "2. **Function Signatures**: Define clear input/output specifications\n",
                    "3. **Quantum Libraries**: Specify which quantum framework you're using\n",
                    "4. **Error Handling**: Ask for robust error handling in quantum operations\n",
                    "5. **Step-by-Step Plans**: Break complex operations into manageable steps\n",
                    "\n",
                    "### üíª **Example: Copilot-Assisted Implementation**\n",
                    "\n",
                    "Try this with Copilot:\n",
                    "```python\n",
                    "def create_quantum_circuit_for_bb84(num_qubits):\n",
                    "    \"\"\"\n",
                    "    Create a quantum circuit for BB84 protocol simulation.\n",
                    "    \n",
                    "    Args:\n",
                    "        num_qubits (int): Number of qubits to use in the circuit\n",
                    "        \n",
                    "    Returns:\n",
                    "        qutip.Qobj: The quantum circuit as a unitary operator\n",
                    "    \"\"\"\n",
                    "    # TODO: Implement quantum circuit creation with Copilot's help\n",
                    "    # Steps that Copilot can assist with:\n",
                    "    # 1. Create initial quantum state\n",
                    "    # 2. Apply quantum gates (Hadamard, CNOT, etc.)\n",
                    "    # 3. Handle measurement operations\n",
                    "    # 4. Implement error correction\n",
                    "    \n",
                    "    pass\n",
                    "```\n",
                    "\n",
                    "**üí° Tip**: Place your cursor after the `pass` statement and start typing. Copilot will suggest quantum operations based on your comments!"
                ]
            },
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "## üéâ Section 6: What You've Learned & Next Steps\n",
                    "\n",
                    "### ‚úÖ **Congratulations! You've Completed:**\n",
                    "\n",
                    "1. **üåê Quantum Networking Fundamentals**\n",
                    "   - Understanding of quantum superposition and entanglement\n",
                    "   - Knowledge of quantum security principles\n",
                    "   - Awareness of current quantum networking research\n",
                    "\n",
                    "2. **üîê BB84 Protocol Implementation**\n",
                    "   - Step-by-step understanding of BB84\n",
                    "   - Hands-on implementation of quantum key distribution\n",
                    "   - Experience with eavesdropper detection\n",
                    "\n",
                    "3. **üíª Code Scaffolding & Development**\n",
                    "   - Building quantum protocols from scratch\n",
                    "   - Understanding quantum algorithm structure\n",
                    "   - Best practices for quantum programming\n",
                    "\n",
                    "4. **ü§ñ AI-Assisted Quantum Coding**\n",
                    "   - Integration with GitHub Copilot\n",
                    "   - Efficient quantum algorithm development\n",
                    "   - Modern development workflow for quantum computing\n",
                    "\n",
                    "### üöÄ **Next Steps:**\n",
                    "\n",
                    "1. **Experiment with Parameters**: Try different key lengths and bases\n",
                    "2. **Implement Variations**: Modify BB84 for different scenarios\n",
                    "3. **Add Visualization Features**: Customize plots and charts\n",
                    "4. **Integrate with Your Project**: Connect BB84 to your existing quantum network\n",
                    "\n",
                    "### üéØ **Final Challenge: Create Your Own Quantum Protocol!**\n",
                    "\n",
                    "Think about:\n",
                    "1. **What problem does your protocol solve?**\n",
                    "2. **How does it use quantum mechanics?**\n",
                    "3. **What are the security properties?**\n",
                    "4. **How would you implement it?**\n",
                    "\n",
                    "**Use Copilot to help implement your ideas!**\n",
                    "\n",
                    "---\n",
                    "\n",
                    "**üèÅ You've successfully learned quantum networking and implemented BB84!**\n",
                    "\n",
                    "**üí° Remember: Copilot is your quantum coding partner! üöÄ**\n",
                    "\n",
                    "**üéâ Ready to build the quantum internet of the future!**"
                ]
            }
        ],
        "metadata": {
            "kernelspec": {
                "display_name": "Python 3",
                "name": "python3"
            },
            "language_info": {
                "codemirror_mode": {
                    "name": "ipython",
                    "version": 3
                },
                "file_extension": ".py",
                "mimetype": "text/x-python",
                "name": "python",
                "nbconvert_exporter": "python",
                "pygments_lexer": "ipython3",
                "version": "3.8.5"
            }
        },
        "nbformat": 4,
        "nbformat_minor": 4
    }
    
    # Write the notebook to file
    with open('quantum_networking_bb84.ipynb', 'w', encoding='utf-8') as f:
        json.dump(notebook, f, indent=2, ensure_ascii=False)
    
    print("‚úÖ Jupyter notebook 'quantum_networking_bb84.ipynb' created successfully!")
    print("\nüöÄ Next steps:")
    print("1. Open Jupyter: jupyter notebook")
    print("2. Navigate to your notebook file")
    print("3. Start implementing the BB84 protocol!")
    print("4. Use GitHub Copilot for assistance")

if __name__ == "__main__":
    create_quantum_notebook()
